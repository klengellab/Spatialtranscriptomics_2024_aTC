# Functions for the processing of visium spatial transcriptomics RNA-seq data
# Created by Shu Dan and Joy Otten

pseudo_bulk_raw <- function(layers, sample, sample_name, verbose = FALSE){
  
  # Pseudo bulk the counts of genes of all spots assigned to a layer. 
  # -------------
  # Parameters:
  # layers: List of strings. All layers of interest. 
  # sample: Seurat object. A sample with normalized data, prediction scores, and layer assignment 
  # sample_name: Chr/string. Name of the sample. 
  # verbose: Boolean. whether to print process information.
  # -------------
  # Returns:
  # count_matrix: DataFrame. Pseudo bulked count matrix of a sample. [number of genes, number of layers]
  
  # layer count matrix: number of genes, number of samples
  # one count matrix per sample
  
  count_matrix <- DataFrame()
  
  for(i in layers){
    if(verbose){message(i)}
    layer_idx <- grepl(i,sample$layer_assign, fixed = TRUE)
    
    # need to check it has at least one spot assigned to this layer
    if(sum(layer_idx) > 0){
      
      all_count <- as.data.frame(sample@assays[["Spatial"]]@counts)
      layer_count <- all_count[,layer_idx]
      
      if (sum(layer_idx) == 1){
        
        # make sure not to sum if there's only one spot
        if(verbose){ message("only 1 spot fould in layer") }
        count_matrix[i] <- as.data.frame(layer_count)
        
      }else{
        
        if(verbose){ message(paste0(sum(layer_idx), " spots found in layer")) }
        count_matrix[i] <- as.data.frame(apply(layer_count, 1, sum)) # [number of genes, 1]
      }
    }else{
      
      if(verbose){ message("no spot found in layer") }
    }
  }
  
  # make sure that the column names of the count matrix contains sample name for downstream analysis
  count_matrix <- as.data.frame(count_matrix)
  colnames(count_matrix) <- paste(colnames(count_matrix), sample_name, sep = "_")
  
  return(count_matrix)
}

de_limma <- function (layer_count, group, design = design, coef = NULL, p_adj_method = "BH", weights = FALSE, contrast = NULL, plot = FALSE, metadata_layer){
  
  # basic limma analysis to fit linear model
  ###==============================================================================================###
  # Parameters:
  # layer_count: count matrix of a layer in all samples. (number of genes, number of samples)
  # group: matrix of group (number of samples, number of groups)
  # formula: A character string that can be coerced to a formula for fitting the linear model
  # coef: list or character string. specifies which column of the coefficients to output from limma::topTable
  # p_adj_method: character string. method to adjust p-values. Default set as "BH"
  # weights: logical. set TRUE to add sample-level weights 
  # contrast: matrix. generated by limma:makeContrasts and fit model on contrast group models.
  # plot: logical. set TRUE to see voom plot
  ###==============================================================================================###
  # Return:
  # list. voom_count: voom transformed counts; fit: limma fitted model; res: topTable list of limma output
  
  #normalization and filtering
  d <- DGEList(layer_count)
  
  # remove rows that consistenly have 0 or very low counts
  keep <- filterByExpr(d, group)
  d_keep <- d[keep, keep.lib.sizes = FALSE]
  
  set <- newSeqExpressionSet(as.matrix(d_keep), phenoData = metadata_layer)
  plotRLE(set, outline = FALSE, ylim=c(-4,4))
  
  d_keep <- calcNormFactors(d_keep, method = "TMM")
  
  #design_group <- model.matrix(as.formula(formula))
  #design_group <- formula
  
  if(weights == TRUE){
    v <- voomWithQualityWeights(d_keep, design, plot = plot)
  } else {
    # v <- voom(d_keep, design_group, plot = plot) 
    v <- voom(d_keep, design, plot = plot)
    
  }
  
  fit <- lmFit(v, design)
  
  if(!is.null(contrast)){
    fit <- contrasts.fit(fit, contrast)
  }
  
  efit <- eBayes(fit)
  results <- decideTests(efit)
  res <- limma::topTable(efit, coef = coef, adjust.method = p_adj_method, number = Inf)
  output <- list("d_norm" = d_keep, "voom_count" = v, "efit" = efit, "res" = res)
  return(output)
}

bacon_limma <- function(efit, res, coef, plot = FALSE){
  
  # bacon_limma: apply bacon to the p-values and 
  ###==============================================================================================###
  # Parameters:
  # res: limma::topTable output
  # efit: eBayes fitted model
  # coef: character string. need to match resultsName in limma::topTable output to specify the coefficients
  #       to compute bacon results on
  # plot: whether to plot QC plots and print p-lambda both before and after bacon adjustment for QC
  ###==============================================================================================###
  # Return:
  # list. genes: differentially expressed genes; res: topTable output with bacon adjusted p-values
  
  if(plot){ 
    p_lambda <- P_lambda(res$P.Value)
    message(paste0("Lambda of p-values is ", p_lambda))
    plot(y = -log10(sort(res$P.Value,decreasing=FALSE)), x = -log10( ppoints(length(res$P.Value))),
         xlab = "expected -log10",
         ylab = "observed -log10",
         main = paste("QQ plot of limma p-values \nLambda of p-values is ", p_lambda, sep = ""))
    abline(0,1,col = "red")
    
    hist(res$P.Value, breaks=20, col="grey")
  }
  
  
  bc <- bacon((efit$coef/efit$stdev.unscaled/efit$sigma)[, coef])
  res$baconP <- bacon::pval(bc)[rownames(res), 1]
  res$baconFDR <- p.adjust(res$baconP, method = "BH")
  genes <- rownames(res[res$baconFDR < 0.05,])
  
  if(plot){ 
    p_lambda_bacon <- P_lambda(res$baconP)
    message(paste0("Lambda of bacon adjusted p-values is ", p_lambda_bacon))
    plot(y = -log10(sort(res$baconP,decreasing=FALSE)), x = -log10( ppoints(length(res$baconP))),
         xlab = "expected -log10",
         ylab = "observed -log10",
         main = paste("QQ plot of bacon adjusted p-values \nLambda of p-values is ", p_lambda_bacon, sep = ""))
    abline(0,1,col = "red")
    
    hist(res$baconP, breaks=20, col="grey")
  }
  
  return(list("genes" = genes, "res" = res))
}

gene_boxplot_avg <- function(count, layer, gene, group){
  
  # gene_boxplot: plot box plot of a gene of a specific layer across all samples
  # Parameters:   
  ###==============================================================================================###
  # count: DataFrame. Bulk layer count of all layers across all samples (column names: sample name + layer)
  # layer: string. layer of interest
  # gene: string. Name of the gene interested in plotting
  
  #layer_count <- count %>% dplyr::select(matches(paste(layer, "_", sep = "")))
  gene_count <- count[gene,]
  gene_count <- cbind(log(t(gene_count)), group)
  colnames(gene_count) <- c("c","g")
  # p <- boxplot(layer_count[gene,:]~group)
  gene_count <- as.data.frame(gene_count)
  
  ggplot(gene_count, aes(x = as.factor(g), y = c)) + 
    geom_boxplot() +
    theme_classic() +
    geom_dotplot(binaxis = 'y', stackdir = "center", dotsize = 0.5) + 
    stat_summary(fun=mean, geom="point", shape=20, size=3, color="red", fill="red") +
    stat_summary(fun=mean, colour="red", geom="text", 
                 vjust=-0.7, aes( label=round(..y.., digits=3))) +
    theme(text = element_text(size = 15)) +
    labs(x = "Group", y = "Log(normalized count)", title = paste(gene,layer,sep = " ")) + 
    scale_x_discrete(labels= c("CTRL", "FC"))
}

enrichment_analysis <- function(genes, universe){
  enriched <- list()
  # Enrichment analysis with msigdbr/clusterProfiler
  # genes is a character vector of gene names
  # univere is a character vector of gene names
  # Databases are from GSEA
  message("GO analysis")
  GO_datasets <- msigdbr(species = "Mus musculus", category = "C5")
  enriched_GO <- as.data.frame(enricher(genes, universe = universe, pvalueCutoff = 0.05,
                                        qvalueCutoff = 0.05, pAdjustMethod = "BH", TERM2GENE = GO_datasets[,c("gs_name", "gene_symbol")], TERM2NAME = GO_datasets[,c("gs_name", "gs_exact_source")]))
  enriched <- append(enriched, list(enriched_GO))
  
  # KEGG analysis
  message("KEGG analysis")
  KEGG_datasets <- msigdbr(species = "Mus musculus", category = "C2", subcategory = "CP:KEGG")
  enriched_KEGG <- as.data.frame(enricher(genes, universe = universe, pvalueCutoff = 0.05, 
                                          qvalueCutoff = 0.05, pAdjustMethod = "BH", TERM2GENE = KEGG_datasets[,c("gs_name", "gene_symbol")]))
  enriched_KEGG$Description <- str_sub(enriched_KEGG$ID,6) 
  enriched_KEGG$Description <- str_replace_all(enriched_KEGG$Description, "_", " ")
  
  enriched <- append(enriched, list(enriched_KEGG))
  
  # Reactome analysis
  message("Reactome analysis")
  reactome_datasets <- msigdbr(species = "Mus musculus", category = "C2", subcategory = "CP:REACTOME")
  enriched_reactome <- as.data.frame(enricher(genes, universe = universe, pvalueCutoff = 0.05, 
                                              qvalueCutoff = 0.05, pAdjustMethod = "BH", TERM2GENE = reactome_datasets[,c("gs_name", "gene_symbol")]))
  enriched_reactome$Description <- str_sub(enriched_reactome$Description, 10)
  enriched_reactome$ID <- str_sub(enriched_reactome$ID, start = 1, end = 8)
  
  enriched <- append(enriched, list(enriched_reactome))
  
  
  names(enriched) <- c("GO", "KEGG", "Reactome")
  
  return(enriched)
}

gene_boxplot <- function(count, layer, gene, group){
  
  # gene_boxplot: plot box plot of a gene of a specific layer across all samples
  # Parameters:   
  ###==============================================================================================###
  # count: DataFrame. Bulk layer count of all layers across all samples (column names: sample name + layer)
  # layer: string. layer of interest
  # gene: string. Name of the gene interested in plotting
  
  #layer_count <- count %>% dplyr::select(matches(paste(layer, "_", sep = "")))
  gene_count <- count[gene,]
  gene_count <- cbind(log(t(gene_count)), group)
  colnames(gene_count) <- c("c","g")
  # p <- boxplot(layer_count[gene,:]~group)
  gene_count <- as.data.frame(gene_count)
  layer <- as.character(layer)
  ggplot(gene_count, aes(x = factor(g), y = c)) + 
    geom_boxplot()+
    geom_dotplot(binaxis = 'y', stackdir = "center", dotsize = 0.5) + 
    geom_text(label = rownames(gene_count), nudge_x = 0.25) +
    labs(x = "Group", y = "Log2(normalized count)", title = paste0(gene, " ", layer)) + 
    scale_x_discrete(labels= c("CTRL", "FC")) + theme_classic()
}
